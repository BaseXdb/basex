
options {
  STATIC = false;
  USER_TOKEN_MANAGER = true;
  GRAMMAR_ENCODING = "UTF-8";
  JDK_VERSION = "1.6";
}

PARSER_BEGIN(RegExParser)

package org.basex.query.regex.parse;

import static org.basex.query.util.Err.*;

import java.util.ArrayList;
import java.util.regex.*;

import org.basex.query.*;
import org.basex.query.regex.*;
import org.basex.query.util.*;
import org.basex.util.*;
import static org.basex.util.Token.*;
import static java.util.regex.Pattern.*;

/**
 * A parser for XSD regular expressions.
 *
 * @author BaseX Team 2005-12, BSD License
 * @author Leo Woerteler
 */
@SuppressWarnings("all")
public class RegExParser {
  /** Group counter. */
  private int groups;
  /** Current backref's number. */
  private int backref;
  /** Closed groups. */
  private final BitArray closed = new BitArray();
  /** If the wildcard {@code .} matches any character. */
  private boolean dotAll;
  /** Multi-line matching mode, {@code ^} and {@code $} match on line bounds. */
  private boolean multiLine;
  /** Case-insensitive match. */
  private boolean noCase;

  /**
   * Compiles this regular expression to a {@link Pattern}.
   * @param mod modifiers
   * @param ext XQuery 3.0 syntax
   * @param ii input info
   * @return the pattern
   * @throws QueryException query exception
   */
  public static Pattern parse(final byte[] regex, final byte[] mod, final boolean ext,
      final InputInfo ii) throws QueryException {
    // process modifiers
    int m = Pattern.UNIX_LINES;
    boolean strip = false, dotAll = false, multi = false;
    if(mod != null) {
      for(final byte b : mod) {
        if(b == 'i') m |= CASE_INSENSITIVE | UNICODE_CASE;
        else if(b == 'm') m |= MULTILINE;
        else if(b == 's') m |= DOTALL;
        else if(b == 'q' && ext) m |= LITERAL;
        else if(b == 'x') strip = true;
        else REGMOD.thrw(ii, (char) b);
      }
    }

    // no need to change anything
    if((m & LITERAL) != 0) return Pattern.compile(string(regex), m);

    try {
      final RegExParser parser = new RegExParser(regex, strip, (m & DOTALL) != 0,
          (m & MULTILINE) != 0, (m & CASE_INSENSITIVE) != 0);
      return Pattern.compile(parser.parse().toString(), m);
    } catch(final ParseException pe) {
      throw Err.REGPAT.thrw(ii, pe.getMessage());
    } catch(final TokenMgrError err) {
      throw Err.REGPAT.thrw(ii, err.getMessage());
    }
  }

  /**
   * Constructor.
   * @param regex regular expression to parse
   * @param strip strip whitespace while lexing
   * @param all dot matches all
   * @param ci case insensitivity
   */
  public RegExParser(final byte[] regex, final boolean strip, final boolean all,
      final boolean multi, final boolean ci) {
    this(new RegExLexer(regex, strip));
    dotAll = all;
    multiLine = multi;
    noCase = ci;
  }
}

PARSER_END(RegExParser)

  /** Root production. */
  RegExp parse() : {
    RegExp regex;
  } {
    regex = regExp() <EOF> {
      return regex;
    }
  }

  /**
   * Parses the "regExp" rule.
   */
  RegExp regExp() : {
    RegExp nd;
    RegExp[] brs = null;
  } {
    (
      nd = branch() {
        brs = new RegExp[] { nd };
      }
      (
        <OR> nd = branch() {
          final RegExp[] nw = new RegExp[brs.length + 1];
          System.arraycopy(brs, 0, nw, 0, brs.length);
          nw[brs.length] = nd;
          brs = nw;
        }
      )*
    ) {
      return brs.length == 1 ? nd : new Disjunction(brs);
    }
  }

  /**
   * Parses the "branch" rule.
   * Parses the "piece" rule.
   */
  RegExp branch() : {
    RegExp atom;
    RegExp[] pieces = new RegExp[0];
    Quantifier qu = null;
  } {
    (
      ( atom = atom() [ qu = quantifier() ] ) {
        final RegExp[] nw = new RegExp[pieces.length + 1];
        System.arraycopy(pieces, 0, nw, 0, pieces.length);
        nw[pieces.length] = qu == null ? atom : new Piece(atom, qu);
        pieces = nw;
        qu = null;
      }
    )* {
      return pieces.length == 1 ? pieces[0] : new Branch(pieces);
    }
  }

  /**
   * Parses the "quantifier" rule.
   */
  Quantifier quantifier() : {
    int min = 0, max = 0;
    boolean lazy = false;
    int[] qu = null;
  } {
    ( <Q_MARK> { max = 1; }
    | <STAR>   { max = -1; }
    | <PLUS>   { min = 1; max = -1; }
    | ( <QUANT_OPEN> qu = quantity() { min = qu[0]; max = qu[1]; } <QUANT_CLOSE> )
    )
    [ <Q_MARK> { lazy = true; } ]
    {
      return new Quantifier(min, max, lazy);
    }
  }

  /**
   * Parses the "quantity" rule.
   * Parses the "quantRange" rule.
   * Parses the "quantMin" rule.
   * Parses the "quantExact" rule.
   */
  int[] quantity() : {
    final int[] qty = new int[2];
  } {
    <NUMBER> { qty[0] = qty[1] = (Integer) token.getValue(); }
    [
      <COMMA> { qty[1] = -1; }
      [ <NUMBER> {
          qty[1] = (Integer) token.getValue();
          if(qty[0] > qty[1]) throw new ParseException("Illegal quantifier, " +
              "lower > upper bound: {" + qty[0] + "," + qty[1] + "}");
        }
      ]
    ] {
      return qty;
    }
  }

  /**
   * Parses the "atom" rule.
   */
  RegExp atom() : {
    RegExp nd = null;
  } {
    ( nd = Char()
    | nd = charClass()
    | (<NPAR_OPEN> nd = regExp() <PAR_CLOSE>) {
        nd = new Group(nd, false);
      }
    | (<PAR_OPEN> { final int grp = ++groups; }
        nd = regExp()
      <PAR_CLOSE>) {
        closed.set(grp);
        nd = new Group(nd, true);
      }
    | nd = backReference()
    ) {
      return nd;
    }
  }

  /**
   * Parses the "Char" rule.
   */
  Literal Char() : {
  } {
    ( <CHAR>
    | <DIGIT>
    )
    { return new Literal(token.image.codePointAt(0)); }
  }

  /**
   * Parses the "backReference" rule.
   */
  BackRef backReference() : {
    Token tok;
  } {
    tok = <BACK_REF> {
      backref = token.image.charAt(1) - '0';
    }
    (
      LOOKAHEAD(1, { 10 * backref + token.next.image.charAt(0) - '0' <= groups })
      <DIGIT> {
        backref = 10 * backref + token.image.charAt(0) - '0';
      }
    )* {
      if(!closed.get(backref))
        throw new ParseException("Illegal back-reference: \\" + backref);
      return new BackRef(backref);
    }
  }

  /**
   * Parses the "charClass" rule.
   */
  RegExp charClass() : {
    RegExp nd = null;
  } {
    ( nd = charClassEsc()
    | nd = charClassExpr()
    | <WILDCARD>   { nd = Wildcard.get(dotAll); }
    | <LINE_START> { nd = LineBorder.get(true, multiLine); }
    | <LINE_END>   { nd = LineBorder.get(false, multiLine); }
    ) {
      return nd;
    }
  }

  /**
   * Parses the "charClassEsc" rule.
   */
  RegExp charClassEsc() : { } {
    ( <SINGLE_ESC>
    | <MULTI_ESC>
    | <CAT_ESC>
    ) {
      final RegExp esc = Escape.get(token.image);
      if(esc == null) throw new ParseException("Unknown escape: " + token);
      return esc;
    }
  }

  /**
   * Parses the "charClassExpr" rule.
   * Parses the "charClassSub" rule.
   */
  CharClass charClassExpr() : {
    CharGroup group = null;
    CharClass sub = null;
  } {
    <BR_OPEN>
      ( LOOKAHEAD(1) <NEG> group = posCharGroup() {
          group.negative = true;
        }
      | group = posCharGroup()
      )
      [ <TO> sub = charClassExpr() ]
    <BR_CLOSE> {
      return new CharClass(group, sub);
    }
  }

  /**
   * Parses the "posCharGroup" rule.
   */
  CharGroup posCharGroup() : {
    final ArrayList<RegExp> cg = new ArrayList<RegExp>();
    RegExp sub = null;
  } {
    ( LOOKAHEAD(3) sub = charRange() { cg.add(sub); }
    | (<SINGLE_ESC> | <MULTI_ESC>| <CAT_ESC>) {
        for(final RegExp re : Escape.inGroup(token.image)) cg.add(re);
      }
    )+ {
      return new CharGroup(cg.toArray(new RegExp[cg.size()]));
    }
  }

  /**
   * Parses the "charRange" rule.
   */
  RegExp charRange() : {
    int a = -1, b = -1;
  } {
    ( LOOKAHEAD({ getToken(2).kind == CHAR && "-".equals(getToken(2).image) })
      (a = charOrEsc() <CHAR> b = charOrEsc()) {
        if(a > b) throw new ParseException("Illegal range, " +
            "lower > upper bound: " + Literal.escape(a) + "-" + Literal.escape(b));
      }
    | a = XmlChar()
    ) {
      return b == -1 ? new Literal(a) : new CharRange(a, b);
    }
  }

  /**
   * Parses the "charOrEsc" rule.
   */
  int charOrEsc() : {
    int cp = -1;
  } {
    ( cp = XmlChar()
    | <SINGLE_ESC> { cp = Escape.getCp(token.image); }
    ) {
      return cp;
    }
  }

  int XmlChar() :  {} {
    ( <CHAR>
    | <DIGIT>
    ) {
      return token.image.codePointAt(0);
    }
  }

