
options {
  STATIC = false;
  USER_TOKEN_MANAGER = true;
  GRAMMAR_ENCODING = "UTF-8";
  JDK_VERSION = "1.6";
}

PARSER_BEGIN(RegExParser)

package org.basex.query.util.regex.parse;

import static org.basex.query.QueryError.*;

import java.util.regex.*;

import org.basex.query.*;
import org.basex.query.util.regex.*;
import org.basex.query.util.*;
import org.basex.util.*;
import static org.basex.util.Token.*;
import static java.util.regex.Pattern.*;

/**
 * A parser for XSD regular expressions.
 *
 * @author BaseX Team 2005-15, BSD License
 * @author Leo Woerteler
 */
@SuppressWarnings("all")
public class RegExParser {
  /** Group counter. */
  private int groups;
  /** Current backref's number. */
  private int backref;
  /** Closed groups. */
  private final BitArray closed = new BitArray();
  /** If the wildcard {@code .} matches any character. */
  private boolean dotAll;
  /** Multi-line matching mode, {@code ^} and {@code $} match on line bounds. */
  private boolean multiLine;

  /**
   * Compiles this regular expression to a {@link Pattern}.
   * @param regex regular expression to parse
   * @param mod modifiers
   * @param ext XQuery 3.0 syntax
   * @param ii input info
   * @param check check result for empty strings
   * @return the pattern
   * @throws QueryException query exception
   */
  public static Pattern parse(final byte[] regex, final byte[] mod, final InputInfo ii,
      final boolean check) throws QueryException {

    // process modifiers
    int m = 0;
    boolean strip = false;
    if(mod != null) {
      for(final byte b : mod) {
        if(b == 'i') m |= CASE_INSENSITIVE | UNICODE_CASE;
        else if(b == 'm') m |= MULTILINE;
        else if(b == 's') m |= DOTALL;
        else if(b == 'q') m |= LITERAL;
        else if(b == 'x') strip = true;
        else throw REGMOD_X.get(ii, (char) b);
      }
    }

    // no need to change anything
    if((m & LITERAL) != 0) return Pattern.compile(string(regex), m);

    try {
      final RegExParser parser = new RegExParser(regex, strip, (m & DOTALL) != 0,
          (m & MULTILINE) != 0);
      final String string = parser.parse().toString();
      final Pattern pattern = Pattern.compile(string, m);
      if(check) {
        // Circumvent Java RegEx behavior ("If MULTILINE mode is activated"...):
        // http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#lt
        final Pattern p = (pattern.flags() & Pattern.MULTILINE) == 0 ? pattern :
          Pattern.compile(pattern.pattern());
        if(p.matcher("").matches()) throw REGROUP.get(ii);
      }
      return pattern;
    } catch(final ParseException ex) {
      Util.debug(ex);
      throw REGPAT_X.get(ii, regex);
    } catch(final TokenMgrError ex) {
      Util.debug(ex);
      throw REGPAT_X.get(ii, regex);
    }
  }

  /**
   * Constructor.
   * @param regex regular expression to parse
   * @param strip strip whitespace while lexing
   * @param all dot matches all
   * @param multi multi line search
   */
  public RegExParser(final byte[] regex, final boolean strip, final boolean all,
      final boolean multi) {
    this(new RegExLexer(regex, strip));
    dotAll = all;
    multiLine = multi;
  }
}

PARSER_END(RegExParser)

  /**
   * Root production.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp parse() : {
    RegExp regex;
  } {
    regex = regExp() <EOF> {
      return regex;
    }
  }

  /**
   * Parses the "regExp" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp regExp() : {
    final RegExpList brs = new RegExpList();
  } {
    (
      { brs.add(branch()); }
      (
        <OR> { brs.add(branch()); }
      )*
    ) {
      return brs.size() == 1 ? brs.get(0) : new Disjunction(brs.finish());
    }
  }

  /**
   * Parses the "branch" rule.
   * Parses the "piece" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp branch() : {
    RegExp atom;
    final RegExpList pieces = new RegExpList();
    Quantifier qu = null;
  } {
    (
      ( atom = atom() [ qu = quantifier() ] ) {
        pieces.add(qu == null ? atom : new Piece(atom, qu));
        qu = null;
      }
    )* {
      return pieces.size() == 1 ? pieces.get(0) : new Branch(pieces.finish());
    }
  }

  /**
   * Parses the "quantifier" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  Quantifier quantifier() : {
    int min = 0, max = 0;
    boolean lazy = false;
    int[] qu = null;
  } {
    ( <Q_MARK> { max = 1; }
    | <STAR>   { max = -1; }
    | <PLUS>   { min = 1; max = -1; }
    | ( <QUANT_OPEN> qu = quantity() { min = qu[0]; max = qu[1]; } <QUANT_CLOSE> )
    )
    [ <Q_MARK> { lazy = true; } ]
    {
      return new Quantifier(min, max, lazy);
    }
  }

  /**
   * Parses the "quantity" rule.
   * Parses the "quantRange" rule.
   * Parses the "quantMin" rule.
   * Parses the "quantExact" rule.
   * @return quantity
   * @throws ParseException parsing exception
   */
  int[] quantity() : {
    final int[] qty = new int[2];
  } {
    <NUMBER> {
      try {
        qty[0] = qty[1] = Integer.parseInt((String) token.getValue());
      } catch(final NumberFormatException ex) {
        throw new ParseException("Number in quantifier is too large");
      }
    }
    [
      <COMMA> { qty[1] = -1; }
      [ <NUMBER> {
          try {
            qty[1] = Integer.parseInt((String) token.getValue());
          } catch(final NumberFormatException ex) {
            throw new ParseException("Number in quantifier is too large");
          }
          if(qty[0] > qty[1]) throw new ParseException("Illegal quantifier: " +
              qty[0] + " > " + qty[1]);
        }
      ]
    ] {
      return qty;
    }
  }

  /**
   * Parses the "atom" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp atom() : {
    RegExp nd = null;
  } {
    ( nd = Char()
    | nd = charClass()
    | (<NPAR_OPEN> nd = regExp() <PAR_CLOSE>) {
        nd = new Group(nd, false);
      }
    | (<PAR_OPEN> { final int grp = ++groups; }
        nd = regExp()
      <PAR_CLOSE>) {
        closed.set(grp);
        nd = new Group(nd, true);
      }
    | nd = backReference()
    ) {
      return nd;
    }
  }

  /**
   * Parses the "Char" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  Literal Char() : {
  } {
    ( <CHAR>
    | <DIGIT>
    )
    { return new Literal(token.image.codePointAt(0)); }
  }

  /**
   * Parses the "backReference" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  BackRef backReference() : {
    Token tok;
  } {
    tok = <BACK_REF> {
      backref = token.image.charAt(1) - '0';
    }
    (
      LOOKAHEAD(1, { 10 * backref + token.next.image.charAt(0) - '0' <= groups })
      <DIGIT> {
        backref = 10 * backref + token.image.charAt(0) - '0';
      }
    )* {
      if(!closed.get(backref))
        throw new ParseException("Illegal back-reference: \\" + backref);
      return new BackRef(backref);
    }
  }

  /**
   * Parses the "charClass" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp charClass() : {
    RegExp nd = null;
  } {
    ( nd = charClassEsc()
    | nd = charClassExpr()
    | <WILDCARD>   { nd = Wildcard.get(dotAll); }
    | <LINE_START> { nd = LineBorder.get(true, multiLine); }
    | <LINE_END>   { nd = LineBorder.get(false, multiLine); }
    ) {
      return nd;
    }
  }

  /**
   * Parses the "charClassEsc" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp charClassEsc() : { } {
    ( <SINGLE_ESC>
    | <MULTI_ESC>
    | <CAT_ESC>
    ) {
      final RegExp esc = Escape.get(token.image);
      if(esc == null) throw new ParseException("Unknown escape: " + token);
      return esc;
    }
  }

  /**
   * Parses the "charClassExpr" rule.
   * Parses the "charClassSub" rule.
   * @return character class
   * @throws ParseException parsing exception
   */
  CharClass charClassExpr() : {
    CharGroup group = null;
    CharClass sub = null;
  } {
    <BR_OPEN>
      ( LOOKAHEAD(1) <NEG> group = posCharGroup() {
          group.negative = true;
        }
      | group = posCharGroup()
      )
      [ <TO> sub = charClassExpr() ]
    <BR_CLOSE> {
      return new CharClass(group, sub);
    }
  }

  /**
   * Parses the "posCharGroup" rule.
   * @return character group
   * @throws ParseException parsing exception
   */
  CharGroup posCharGroup() : {
    final RegExpList cg = new RegExpList();
    RegExp sub = null;
  } {
    ( LOOKAHEAD(3) sub = charRange() { cg.add(sub); }
    | (<SINGLE_ESC> | <MULTI_ESC>| <CAT_ESC>) {
        for(final RegExp re : Escape.inGroup(token.image)) cg.add(re);
      }
    )+ {
      return new CharGroup(cg.finish());
    }
  }

  /**
   * Parses the "charRange" rule.
   * @return expression
   * @throws ParseException parsing exception
   */
  RegExp charRange() : {
    int a = -1, b = -1;
  } {
    ( LOOKAHEAD({ getToken(2).kind == CHAR && "-".equals(getToken(2).image) })
      (a = charOrEsc() <CHAR> b = charOrEsc()) {
        if(a > b) throw new ParseException("Illegal range: " +
            Literal.escape(a) + " > " + Literal.escape(b));
      }
    | a = XmlChar()
    ) {
      return b == -1 ? new Literal(a) : new CharRange(a, b);
    }
  }

  /**
   * Parses the "charOrEsc" rule.
   * @return character
   * @throws ParseException parsing exception
   */
  int charOrEsc() : {
    int cp = -1;
  } {
    ( cp = XmlChar()
    | <SINGLE_ESC> { cp = Escape.getCp(token.image); }
    ) {
      return cp;
    }
  }

  /**
   * Parses the "XmlChar" rule.
   * @return character
   * @throws ParseException parsing exception
   */
  int XmlChar() :  {} {
    ( <CHAR>
    | <DIGIT>
    ) {
      return token.image.codePointAt(0);
    }
  }

